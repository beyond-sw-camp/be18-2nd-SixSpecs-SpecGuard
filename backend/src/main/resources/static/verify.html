<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SpecGuard - 휴대폰 본인인증</title>

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <!-- QRCodeJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <style>
        body { background: #0b1220; }
    </style>
</head>
<body class="text-slate-100">
<div id="app" class="min-h-screen flex items-center justify-center p-6">
    <div class="bg-slate-900/50 rounded-2xl p-8 w-full max-w-3xl shadow-xl ring-1 ring-slate-800">
        <div class="flex flex-col md:flex-row gap-8">

            <!-- 왼쪽: 설명 + 폼 -->
            <div class="flex-1">
                <h1 class="text-2xl font-extrabold mb-1">휴대폰 본인인증 (Vue)</h1>
                <p class="text-slate-400 mb-6">번호 입력 → 메시지 자동작성 → 전송 → <span class="text-slate-200">인증하기</span></p>

                <!-- 휴대폰 번호 -->
                <div class="mb-4">
                    <label class="block text-sm text-slate-400 mb-1">휴대폰 번호</label>
                    <input v-model.trim="state.phone" class="w-full p-2 rounded bg-slate-800 ring-1 ring-slate-700"
                           placeholder="01012345678" inputmode="numeric" />
                </div>

                <!-- 버튼들 -->
                <div class="flex flex-wrap gap-3 mb-4">
                    <button @click="start" class="px-4 py-2 rounded-xl bg-indigo-500 hover:bg-indigo-600 font-semibold">
                        인증 메시지 생성
                    </button>
                    <button @click="openSms" class="px-4 py-2 rounded-xl bg-sky-500 hover:bg-sky-600 font-semibold">
                        SMS 열기
                    </button>
                    <button @click="finish" class="px-4 py-2 rounded-xl bg-emerald-500 hover:bg-emerald-600 font-semibold">
                        인증하기
                    </button>
                </div>

                <!-- 인증번호 입력 칸 -->
<!--                <div class="mb-4">-->
<!--                    <label class="block text-sm text-slate-400 mb-1">인증번호</label>-->
<!--                    <input v-model.trim="state.token"-->
<!--                           class="w-full p-2 rounded bg-slate-800 ring-1 ring-slate-700"-->
<!--                           placeholder="6자리 숫자"-->
<!--                           inputmode="numeric" />-->
<!--                </div>-->


                <!-- 토큰/상태 -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                    <div class="rounded-xl bg-slate-800 p-3">
                        <div class="text-xs text-slate-400 mb-1">TOKEN</div>
                        <div class="font-mono text-sm break-all">{{ state.token || '-' }}</div>
                    </div>
                    <div class="rounded-xl bg-slate-800 p-3">
                        <div class="text-xs text-slate-400 mb-1">STATUS</div>
                        <div class="font-mono text-sm" :class="statusClass">{{ state.status }}</div>
                    </div>
                </div>

                <!-- 결과 메시지 -->
                <div v-if="state.message" class="mt-4 rounded-xl bg-slate-800 p-3 text-sm">
                    {{ state.message }}
                </div>

                <p class="mt-4 text-xs text-slate-500">
                    * 브라우저/OS 정책상 SMS 수신자 자동 지정이 제한될 수 있으며, 사용자가 직접 확인/전송해야 합니다.
                </p>
            </div>

            <!-- 오른쪽: QR -->
            <div class="w-full md:w-64">
                <div class="rounded-2xl bg-slate-800 p-4 flex flex-col items-center">
                    <div id="qrcode" class="bg-white p-2 rounded shadow"></div>
                    <div class="mt-3 text-xs text-slate-400 text-center break-all">
                        API: {{ state.apiBase }}
                    </div>
                </div>
            </div>

        </div>
    </div>
</div>

<script>
    const { createApp, reactive, computed, onMounted, onUnmounted } = Vue;

    createApp({
        setup() {
            const state = reactive({
                apiBase: 'http://192.168.0.21:8080',
                phone: '',
                channel: 'EMAIL_SMSTO',   // 이메일(iMessage/메일)로 보내려면 유지
                displayToken: '',         // 서버 생성 6자리 (표시만)
                smsLink: '',
                smsBody: '',
                status: 'IDLE',           // IDLE | PENDING | VERIFIED | EXPIRED | FAILED
                message: '',
                pollTimer: null
            });

            const statusClass = computed(() =>
                state.status === 'VERIFIED' ? 'text-emerald-400'
                    : state.status === 'PENDING' ? 'text-yellow-300'
                        : state.status === 'EXPIRED' ? 'text-orange-400'
                            : state.status === 'FAILED'  ? 'text-rose-400'
                                : 'text-slate-300'
            );

            function normalizePhone(p) {
                return (p || '').replace(/[^0-9+]/g, '');
            }

            // 1) 인증 요청
            async function start() {
                state.message = '';
                try {
                    const res = await fetch(`${state.apiBase}/api/verify/phone/start`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            phone: normalizePhone(state.phone),
                            channel: state.channel
                        })
                    });
                    if (!res.ok) throw res;
                    const data = await res.json();

                    state.displayToken = data?.token ?? '';   // 표시만
                    state.smsLink      = data?.smsLink ?? '';
                    state.smsBody      = data?.manualBody ?? '';
                    state.status       = 'PENDING';
                    state.message      = '인증번호가 생성되었습니다. SMS로 전송 후 자동 확인합니다.';

                    // 👉 토큰으로 상태 폴링 시작
                    if (state.displayToken) startPolling(state.displayToken);
                } catch (e) {
                    state.status = 'FAILED';
                    state.message = '인증번호 생성 실패';
                }
            }

            // 2) SMS 열기 (수신처 고정: specguard55@gmail.com)
            function openSms() {
                const isiOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
                const to    = 'specguard55@gmail.com'; // 고정 수신처
                const bodyText = state.smsBody || `[SpecGuard] 인증번호: ${state.displayToken} (5분 유효)`;
                const body = encodeURIComponent(bodyText);

                // iOS는 iMessage로 이메일 수신자 허용, Android는 mailto로 폴백
                const href = isiOS ? `sms:${to}&body=${body}`
                    : `mailto:${to}?subject=${encodeURIComponent('[SpecGuard] 인증번호')}&body=${body}`;
                window.location.href = href;
            }

            // 3) 상태 폴링
            function startPolling(token) {
                stopPolling();
                state.pollTimer = setInterval(async () => {
                    try {
                        const url = `${state.apiBase}/api/verify/phone/poll?token=${encodeURIComponent(token)}`;
                        const res = await fetch(url);
                        if (!res.ok) throw res;
                        const data = await res.json();
                        const s = (data?.status || '').toUpperCase();

                        if (s === 'VERIFIED') {
                            state.status = 'VERIFIED';
                            state.message = '인증이 완료되었습니다.';
                            stopPolling();
                        } else if (s === 'EXPIRED') {
                            state.status = 'EXPIRED';
                            state.message = '인증번호가 만료되었습니다. 다시 시도해 주세요.';
                            stopPolling();
                        } else {
                            state.status = 'PENDING';
                        }
                    } catch (e) {
                        // 네트워크 오류 등은 일시 무시하고 계속 폴링
                    }
                }, 2000);
            }

            function stopPolling() {
                if (state.pollTimer) {
                    clearInterval(state.pollTimer);
                    state.pollTimer = null;
                }
            }

            onMounted(() => {
                // QR은 그대로 유지
                const el = document.getElementById('qrcode');
                el.innerHTML = '';
                new QRCode(el, {
                    text: "http://" + window.location.host + window.location.pathname,
                    width: 180, height: 180, correctLevel: QRCode.CorrectLevel.M
                });
            });

            onUnmounted(stopPolling);

            return { state, statusClass, start, openSms };
        }
    }).mount('#app');

</script>
</body>
</html>